this is what i used: 

import discord
import os
import pandas as pd
from dotenv import load_dotenv

# Load the environment variables
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

# Check if the token is loaded
if not TOKEN:
    print("Error: Discord token not found in .env file!")
    exit()
else:
    print("Token loaded successfully.")

# Define the bot with necessary intents
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
intents.guilds = True
intents.members = True
client = discord.Client(intents=intents)

@client.event
async def on_ready():
    print(f'Bot connected as {client.user}')

@client.event
async def on_message(message):
    print(f"Message received: {repr(message.content)}")

    if message.author == client.user:
        print("Ignored bot's own message.")
        return

    if message.content.strip().lower() == '!test':
        await message.channel.send("Bot is working!")
        return

    if message.content.strip().lower() == '!extract':
        print("Extract command recognized!")
        try:
            await message.channel.send("Processing your request...")

            guild = message.guild
            if not guild:
                print("Guild not found.")
                return

            channels = [ch for ch in guild.text_channels]
            if not channels:
                print("No text channels found.")
                return

            channel_list = "\n".join(f"{idx + 1}. {ch.name}" for idx, ch in enumerate(channels))
            await message.channel.send(f"Select a channel by typing the number:\n{channel_list}")

            def check(m):
                return m.author == message.author and m.channel == message.channel

            reply = await client.wait_for("message", check=check, timeout=30)
            print(f"User input received: {reply.content}")

            channel_index = int(reply.content) - 1

            if channel_index < 0 or channel_index >= len(channels):
                await message.channel.send("Invalid selection. Please try again.")
                return

            selected_channel = channels[channel_index]

            await message.channel.send("Enter the role name to filter messages:")
            reply = await client.wait_for("message", check=check, timeout=30)
            role_name = reply.content
            role = discord.utils.get(guild.roles, name=role_name)

            if not role:
                await message.channel.send(f'Role "{role_name}" not found.')
                return

            messages = []
            async for msg in selected_channel.history(limit=None):
                # Check if message author is a member and has the role
                member = guild.get_member(msg.author.id)
                if member and role in member.roles:
                    messages.append({
                        'Author': str(msg.author),
                        'Content': msg.content,
                        'Timestamp': msg.created_at.isoformat()
                    })

            if messages:
                filename = f'{selected_channel.name}_messages.xlsx'
                print(f"Attempting to save file: {filename}")
                df = pd.DataFrame(messages)
                df.to_excel(filename, index=False)
                await message.channel.send(
                    f'Extracted {len(messages)} messages from "{selected_channel.name}".',
                    file=discord.File(filename)
                )
                os.remove(filename)
            else:
                await message.channel.send(f'No messages found for role "{role_name}".')

        except ValueError:
            await message.channel.send("Please provide valid inputs.")
        except Exception as e:
            print(f"An error occurred: {str(e)}")
            await message.channel.send(f"An error occurred: {str(e)}")

# Run the bot
client.run(TOKEN)
